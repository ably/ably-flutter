import 'package:flutter/foundation.dart';


//==============================================================================
//===============================    ENUM's    =================================
//==============================================================================
enum ChannelState {
  initialized,
  attaching,
  attached,
  detaching,
  detached,
  suspended,
  failed
}

enum ChannelEvent {
  initialized,
  attaching,
  attached,
  detaching,
  detached,
  suspended,
  failed,
  update
}

enum ConnectionState {
  initialized,
  connecting,
  connected,
  disconnected,
  suspended,
  closing,
  closed,
  failed
}

enum ConnectionEvent {
  initialized,
  connecting,
  connected,
  disconnected,
  suspended,
  closing,
  closed,
  failed,
  update
}

enum PresenceAction {
  absent,
  present,
  enter,
  leave,
  update
}

enum StatsIntervalGranularity {
  minute,
  hour,
  day,
  month
}

enum HTTPMethods {
  POST,
  GET
}

/// Java: io.ably.lib.http.HttpAuth.Type
enum HttpAuthType {
  BASIC,
  DIGEST,
  X_ABLY_TOKEN,
}

enum Transport{
  web_socket,
  xhr_streaming,
  xhr_polling,
  jsonp,
  comet
}

enum capabilityOp{
  publish,
  subscribe,
  presence,
  history,
  stats,
  channel_metadata,
  push_subscribe,
  push_admin
}

enum LogLevel{
  none,   //no logs
  errors, //errors only
  info,   //errors and channel state changes
  debug,  //high-level debug output
  verbose //full debug output
}

enum DevicePushState{
  active,
  failing,
  failed
}

enum DevicePlatform{
  android,
  ios,
  browser
}

enum FormFactor{
  phone,
  tablet,
  desktop,
  tv,
  watch,
  car,
  embedded,
  other
}


//==============================================================================
//==========================    ABSTRACT CLASSES    ============================
//==============================================================================
abstract class CipherParams {
  String algorithm;
  dynamic key;
  int keyLength;
  String mode;
}

abstract class ErrorInfo {
  int code;
  String message;
  int statusCode;
}

abstract class StatsMessageCount {
  int count;
  int data;
}

abstract class StatsMessageTypes {
  StatsMessageCount all;
  StatsMessageCount messages;
  StatsMessageCount presence;
}

abstract class StatsRequestCount {
  int failed;
  int refused;
  int succeeded;
}

abstract class StatsResourceCount {
  int mean;
  int min;
  int opened;
  int peak;
  int refused;
}

abstract class StatsConnectionTypes {
  StatsResourceCount all;
  StatsResourceCount plain;
  StatsResourceCount tls;
}

abstract class StatsMessageTraffic {
  StatsMessageTypes all;
  StatsMessageTypes realtime;
  StatsMessageTypes rest;
  StatsMessageTypes webhook;
}

abstract class TokenParams {
  String  capability;   //See below -v-
  Map<String, List<capabilityOp>> capabilityMap;	//optional
  String clientId;
  String nonce;
  int timestamp;
  int ttl;
}

abstract class TokenDetails {
  String capability;
  String clientId;
  int expires;
  int issued;
  String token;
}

abstract class TokenRequest {
  String capability;
  String clientId;
  String keyName;
  String mac;
  String nonce;
  int timestamp;
  int ttl;
}

abstract class ChannelOptions {
  dynamic cipher;
}

abstract class RestHistoryParams {
  int start;
  int end;
  String direction;
  int limit;
}

abstract class RestPresenceParams {
  int limit;
  String clientId;
  String connectionId;
}

abstract class RealtimePresenceParams {
  bool waitForSync; //waitForSync;	//?: bool;
  String clientId; //clientId;	//?: String;
  String connectionId; //;	//?: String;
}

abstract class RealtimeHistoryParams {
  int start; //  start;	//?: int;
  int end; //  end;	//?: int;
  int direction; //  direction;	//?: String;
  int limit; //  limit;	//?: int;
  bool untilAttach; //  untilAttach;	//?: bool;
}


/// An exception generated by the client library SDK called by this plugin.
class LibraryException implements Exception {}

typedef void LogHandler({String msg, LibraryException exception});
class LogInfo{

  LogInfo({
    this.level = LogLevel.info,
    LogHandler handler
  });

  ///A int controlling the verbosity of the output.
  ///Valid values are: 0 (no logs), 1 (errors only),
  ///2 (errors plus connection and channel state changes), 3 (high-level debug output), and 4 (full debug output).
  LogLevel level;  //level?: int;

  /// A function to handle each line of log output.
  /// If handler is not specified, console.log is used.
  LogHandler handler;

  void log({String msg, LibraryException exception}){
    if(handler==null){
      print(exception??msg);
    }else{
      handler(msg: msg, exception: exception);
    }
  }
}

/// Java: io.ably.lib.types.ProxyOptions
class ProxyOptions {
  String host;
  int port;
  String username;
  String password;
  List<String> nonProxyHosts;
  HttpAuthType prefAuthType;
}

abstract class ChannelStateChange {
  ChannelState current;
  ChannelState previous;
  ErrorInfo reason; //optional
  bool resumed;
}

abstract class ConnectionStateChange {
  ConnectionState current;
  ConnectionState previous;
  ErrorInfo reason; //optional
  int retryIn;      //optional
}

abstract class DevicePushDetails {
  dynamic recipient;
  DevicePushState state;  //optional
  ErrorInfo errorReason;  //optional
}

abstract class DeviceDetails {
  String id;
  String clientId;  //optional
  DevicePlatform platform;
  FormFactor formFactor;
  dynamic metadata; //optional
  String deviceSecret;  //optional
  DevicePushDetails push; //optional
}

abstract class PushChannelSubscription {
  String channel;
  String deviceId;  //optional
  String clientId;  //optional
}

abstract class DeviceRegistrationParams {
  String clientId;  //optional
  String deviceId;  //optional
  int limit;  //optional
  DevicePushState state;  //optional
}

abstract class PushChannelSubscriptionParams {
  String channel;  //optional
  String clientId;  //optional
  String deviceId;  //optional
  int limit;    //optional
}

abstract class PushChannelsParams {
  int limit;    //optional
}

// Interfaces

/// Function-type alias implemented by a function that provides either tokens,
/// or signed token requests, in response to a request with given token params.
///
/// Java: io.ably.lib.rest.Auth.TokenCallback.getTokenRequest(TokenParams)
/// returns either [TokenDetails] or [TokenRequest]
typedef dynamic AuthCallback(TokenParams params);
abstract class AuthOptions {

  AuthOptions();

  /// Convenience constructor, to create an AuthOptions based
  /// on the key string obtained from the application dashboard.
  /// param [key]: the full key string as obtained from the dashboard
  AuthOptions.fromKey(String key){
    assert(key!=null);
    if(key.contains(':')){
      this.key = key;
    }else{
      this.token = key;
    }
  }

  ///A function which is called when a new token is required.
  ///The role of the callback is to either generate
  /// a signed TokenRequest which may then be submitted automatically
  ///by the library to the Ably REST API requestToken;
  /// or to provide a valid token in as a TokenDetails object.
  AuthCallback authCallback;

  ///A URL that the library may use to obtain a
  /// token String (in plain text format),
  /// or a signed TokenRequest or TokenDetails (in JSON format).
  String authUrl;	//optional
  HTTPMethods authMethod;	//optional
  String key;	//optional

  String token;	//optional  TODO remove and strictly use token details?
  TokenDetails tokenDetails;	//optional

  Map<String, String> authHeaders;	//optional
  Map<String, String> authParams;	//optional

  bool queryTime;	//optional
  bool useTokenAuth;	//optional
}


class ClientOptions extends AuthOptions {

  ClientOptions();

  ClientOptions.fromKey(String key): super.fromKey(key);

  ///Optional clientId that can be used to specify the identity for this client.
  /// In most cases it is preferable to instead specific a clientId in the token
  /// issued to this client.
  String clientId;	//optional

  ///Logger configuration
  LogInfo log;	//optional

  String restHost;	//optional
  String realtimeHost;	//optional
  int port;	//optional

  ///Use a non-secure connection connection. By default,
  /// a TLS connection is used to connect to Ably
  bool tls;	//optional
  int tlsPort;	//optional

  ///When true will automatically connect to Ably when library is instanced.
  /// This is true by default
  bool autoConnect;	//optional

  /// When true, the more efficient MsgPack binary encoding is used.
  /// When false, JSON text encoding is used.
  bool useBinaryProtocol;	//optional

  ///When true, messages will be queued whilst the connection is disconnected.
  /// True by default.
  bool queueMessages;	//optional

  ///When true, messages published on channels by this client will be
  /// echoed back to this client. This is true by default
  bool echoMessages;  //optional;

  ///Can be used to explicitly recover a connection.
  ///See https://www.ably.io/documentation/realtime/connection#connection-state-recovery
  String recover;

  ///Use this only if you have been provided a dedicated environment by Ably
  String environment;	//optional

  //Fallbacks
  List<String> fallbackHosts;	//optional
  bool fallbackHostsUseDefault;	//optional

  TokenParams defaultTokenParams; //optional

  int disconnectedRetryTimeout;	//optional
  int suspendedRetryTimeout;	//optional
  bool closeOnUnload;	//optional
  bool idempotentRestPublishing;	//optional
  Map<String, String> transportParams;	//optional
  List<Transport> transports;	//optional


  ProxyOptions proxy;

  int httpOpenTimeout;
  int httpRequestTimeout;

  int httpMaxRetryCount;
  int realtimeRequestTimeout;
  int fallbackRetryTimeout;
  int channelRetryTimeout;
  int asyncHttpThreadpoolSize;
  bool pushFullWait;
}


// Internal Classes
/// Interface implemented by event listeners, returned by event emitters.
abstract class EventListener<E> {
  /// Register for all events (no parameter), or a specific event.
  Stream<E> on([E event]);

  /// Register for a single occurrence of any event (no parameter), or a specific event.
  Future<E> once([E event]);

  /// Remove registrations for this listener, irrespective of type.
  Future<void> off();
}

/// Interface implemented by Ably classes that can emit events, offering the capability
/// to create listeners for those events.
abstract class EventEmitter<E> {
  /// Remove all listener registrations, irrespective of type.
  Future<void> off();

  /// Create a listener, with which registrations may be made.
  Future<EventListener<E>> createListener();
}

// Classes
class PushChannelSubscriptions {
  Future<PushChannelSubscription> save(PushChannelSubscription subscription) async {
    //TODO
    return null;
  }
  Future<PaginatedResult<PushChannelSubscription>> list(PushChannelsParams params) async {
    //TODO
    return null;
  }
  Future<PaginatedResult<String>> listChannels(PushChannelsParams params) async {
    //TODO
    return null;
  }
  Future<void> remove(PushChannelsParams params) async {
    //TODO
    return null;
  }
  Future<void> removeWhere(PushChannelSubscriptionParams params) async {
    //TODO
    return null;
  }
}

class PushDeviceRegistrations {
  Future<DeviceDetails> save(DeviceDetails deviceDetails) async {
    //TODO
    return null;
  }
  Future<DeviceDetails> get({
    DeviceDetails deviceDetails, String deviceId
  }) async {
    //TODO
    return null;
  }
  Future<PaginatedResult<DeviceDetails>> list(DeviceRegistrationParams params) async {
    //TODO
    return null;
  }
  Future<void> remove({
    DeviceDetails deviceDetails, String deviceId
  }) async {
    //TODO
    return null;
  }
  Future<void> removeWhere(DeviceRegistrationParams params) async {
    //TODO
    return null;
  }
}

class PushAdmin {
  PushDeviceRegistrations deviceRegistrations;
  PushChannelSubscriptions channelSubscriptions;
  Future<void> publish(Map<String, dynamic> recipient, Map payload) async {
    //TODO
  }
}

class Push {
  PushAdmin admin;
}

class Stats {
  StatsMessageTypes all;
  StatsRequestCount apiRequests;
  StatsResourceCount channels;
  StatsConnectionTypes connections;
  StatsMessageTraffic inbound;
  String intervalId;
  StatsMessageTraffic outbound;
  StatsMessageTypes persisted;
  StatsRequestCount tokenRequests;
}

class PaginatedResult<T> {

  List<T> items(){
    //TODO
    return null;
  }

  Future<PaginatedResult<T>> first() async {
    //TODO
    return null;
  }

  Future<PaginatedResult<T>> next() async {
    //TODO
    return null;
  }

  Future<PaginatedResult<T>> current() async {
    //TODO
    return null;
  }

  bool hasNext(){
    //TODO
    return false;
  }

  bool isLast(){
    //TODO
    return false;
  }

}

class HttpPaginatedResponse extends PaginatedResult<String> {
  // TODO resolve below signature match to this definiton
  // class HttpPaginatedResponse extends PaginatedResult<dynamic> {
  //    items: String[];
  //    .....
  List<String> items();
  int statusCode;
  bool success;
  int errorCode;
  String errorMessage;
  dynamic headers;  //TODO change to Map<String, dynamic> ??
}


// Common Listeners
typedef void FromEncoded<T>(dynamic jsonObject, ChannelOptions channelOptions);
typedef void FromEncodedArray<T>(dynamic jsonArray, ChannelOptions channelOptions);


class Message {
  Message.fromEncoded(Map jsonObject, ChannelOptions channelOptions){
    //TODO
  }
  Message.fromEncodedArray(List jsonArray, ChannelOptions channelOptions){
    //TODO
  }
  String clientId;
  String connectionId;
  dynamic data;
  dynamic encoding;
  dynamic extras;
  String id;
  String name;
  int timestamp;
}

abstract class MessageStatic {  //TODO why is this class required?
  MessageStatic.fromEncoded(Map jsonObject, ChannelOptions channelOptions){
    //TODO
  }
  MessageStatic.fromEncodedArray(List jsonArray, ChannelOptions channelOptions){
    //TODO
  }
}

class PresenceMessage {
  PresenceMessage.fromEncoded(Map jsonObject, ChannelOptions channelOptions){
    //TODO
  }
  PresenceMessage.fromEncodedArray(List jsonArray, ChannelOptions channelOptions){
    //TODO
  }
  PresenceAction action;
  String clientId;
  String connectionId;
  dynamic data;
  String encoding;
  String id;
  int timestamp;
}

abstract class PresenceMessageStatic {  //TODO why is this class required?
  PresenceMessageStatic.fromEncoded(Map jsonObject, ChannelOptions channelOptions){
    //TODO
  }
  PresenceMessageStatic.fromEncodedArray(List jsonArray, ChannelOptions channelOptions){
    //TODO
  }
}

abstract class Crypto {
  String generateRandomKey();
}


abstract class ConnectionBase extends EventEmitter<ConnectionEvent> {

  ///current state of this connection
  ConnectionState state;

  ///Error information associated with connection failure
  ErrorInfo errorReason;

  ///A public identifier for this connection, used to identify
  /// this member in presence events and message ids.
  String id;

  /// The assigned connection key.
  String key;

  /// RTN16b) Connection#recoveryKey is an attribute composed of the
  /// connection key and latest serial received on the connection
  String recoveryKey;

  /// The serial number of the last message to be received on this connection.
  int serial;
  void close();
  void connect();
}


abstract class Connection extends ConnectionBase {
  Future<int> ping();
//  Future<ConnectionStateChange> whenState(ConnectionState targetState); //TODO remove?
}


//REST BASE

///io.ably.lib.rest.AblyBase
abstract class RestBase {
  RestBase.fromOptions(this.options);
  RestBase.fromKey(String key){
    this.options = ClientOptions.fromKey(key);
  }
  ClientOptions options;
  static Crypto crypto;
  static MessageStatic message;
  static PresenceMessageStatic presenceMessage;
  Future<PaginatedResult<Stats>> stats([Map<String, dynamic> params]);
}

class Rest extends RestBase { //TODO check if this should be abstract!
  Rest.fromOptions(ClientOptions options): super.fromOptions(options);
  Rest.fromKey(String key): super.fromKey(key);
  static Rest rest; //todo factory?
  Auth auth;
  Channels<Channel> channels;
  Future<HttpPaginatedResponse> request({
    @required String method,
    @required String path,
    Map params, //TODO decide if this needs to be a map
    dynamic body, //?: dynamic[] | dynamic,
    Map headers //TODO decide if this needs to be a map?: dynamic
  }) async {
    //TODO
    return null;
  }
  Future<PaginatedResult<Stats>> stats([Map<String, dynamic> params]){
    //TODO
    return null;
  }
  Future<int> time() async {
    //TODO
    return null;
  }
  Push push;
}

abstract class RealtimeBase extends RestBase {
  RealtimeBase.fromOptions(ClientOptions options): super.fromOptions(options);
  RealtimeBase.fromKey(String key): super.fromKey(key);
  static Realtime realtime; //todo factory?
  String clientId;
  void close();
  void connect();
}

class Realtime extends RealtimeBase {
  Realtime.fromOptions(ClientOptions options): super.fromOptions(options);
  Realtime.fromKey(String key): super.fromKey(key);
  Auth auth;
  Channels<RealtimeChannel> channels;
  Connection connection;
  Future<HttpPaginatedResponse> request({
    @required String method,
    @required String path,
    Map params, //TODO decide if this needs to be a map
    dynamic body, //?: dynamic[] | dynamic,
    Map headers //TODO decide if this needs to be a map?: dynamic
  }) async {
    //TODO
    return null;
  }

  Future<int> time() async {
    //TODO
    return null;
  }

  Push push;

  Future<PaginatedResult<Stats>> stats([Map<String, dynamic> params]){
    //TODO
    return null;
  }

  close(){
    //TODO
  }

  connect(){
    //TODO
  }

}

class AuthBase {
  String clientId;
}

class Auth extends AuthBase {
  Future<TokenDetails> authorize({
    TokenParams tokenParams,
    AuthOptions authOptions
  }){
    //TODO
    return null;
  }
  Future<TokenRequest> createTokenRequest({
    TokenParams tokenParams,
    AuthOptions authOptions
  }){
    //TODO
    return null;
  }
  Future<TokenDetails> requestToken({
    TokenParams tokenParams,
    AuthOptions authOptions
  }){
    //TODO
    return null;
  }
}


abstract class Presence {
  Future<PaginatedResult<PresenceMessage>> get([RestPresenceParams params]);
  Future<PaginatedResult<PresenceMessage>> history([RestHistoryParams params]);
}

abstract class RealtimePresenceBase {
  bool syncComplete;
  void unsubscribe({
    PresenceAction action,
    List<PresenceAction> actions,
    EventListener<PresenceMessage> listener //TODO check if this is the type that is expected
  });
}

class RealtimePresence extends RealtimePresenceBase {
  Future<List<PresenceMessage>> get([RealtimePresenceParams params]) async {
    //TODO
    return null;
  }
  Future<PaginatedResult<PresenceMessage>> history([RealtimeHistoryParams params]) async {
    //TODO
    return null;
  }
  Future<void> subscribe({
    PresenceAction action,
    List<PresenceAction> actions,
    EventListener<PresenceMessage> listener //TODO check if this is the type that is expected
  }){
    //TODO
    return null;
  }
  void unsubscribe({
    PresenceAction action,
    List<PresenceAction> actions,
    EventListener<PresenceMessage> listener //TODO check if this is the type that is expected
  }){
    //TODO
  }
  Future<void> enter([dynamic data]){
    //TODO
    return null;
  }
  Future<void> update([dynamic data]){
    //TODO
    return null;
  }
  Future<void> leave([dynamic data]){
    //TODO
    return null;
  }
  Future<void> enterClient({String clientId, dynamic data }) async {
    //TODO
  }
  Future<void> updateClient({String clientId, dynamic data}) async {
    //TODO
  }
  Future<void> leaveClient({String clientId, dynamic data}) async {
    //TODO
  }
}

class ChannelBase {
  String name;
}

class Channel extends ChannelBase {
  Presence presence;
  Future<PaginatedResult<Message>> history([RestHistoryParams params]){
    // TODO
    return null;
  }
  Future<void> publish({String name, dynamic messageData}){
    // TODO
    return null;
  }
}

abstract class RealtimeChannelBase extends EventEmitter<ChannelEvent> {
  String name;
  ErrorInfo errorReason;
  ChannelState state;
  void setOptions(dynamic options);
  void unsubscribe({
    String event,
    List<String> events,
    EventListener<Message> listener //TODO check if this is the type that is expected
  });
}

abstract class RealtimeChannel extends RealtimeChannelBase {  //TODO abstract?
  RealtimePresence presence;
  Future<void> attach();
  Future<void> detach();
  Future<PaginatedResult<Message>> history([RealtimeHistoryParams params]);
  Future<void> subscribe({
    String event,
    List<String> events,
    EventListener<Message> listener
  });
  Future<void> publish({String name, dynamic messageData});
  Future<ChannelStateChange> whenState(ChannelState targetState);
}

abstract class Channels<T> {
  T get(String name, [ChannelOptions channelOptions]);
  void release(String str);
}
